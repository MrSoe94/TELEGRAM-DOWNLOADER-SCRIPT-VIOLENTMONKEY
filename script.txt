// ==UserScript==
// @name         Telegram Web - Enhanced Media Downloader
// @namespace    c0d3r
// @license      MIT
// @version      2.0
// @description  Bypass Telegram's saving content restrictions; download media with buttons, right-click, shortcuts, batch download, and more enhanced features
// @author       c0d3r
// @match        https://web.telegram.org/*
// @match        https://webk.telegram.org/*
// @match        https://webz.telegram.org/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=telegram.org
// @grant        unsafeWindow
// @grant        GM_addStyle
// @grant        GM_notification
// @downloadURL https://update.greasyfork.org/scripts/477900/Telegram%20Web%20-%20Enhanced%20Media%20Downloader.user.js
// @updateURL https://update.greasyfork.org/scripts/477900/Telegram%20Web%20-%20Enhanced%20Media%20Downloader.meta.js
// ==/UserScript==
(function () {
    'use strict';
    // Redirect to WebK version if on WebA
    if (window.location.pathname.startsWith('/a/')) {
        window.location.replace(window.location.href.replace('.org/a/', '.org/k/'));
        return;
    }
    // Enhanced configuration
    const config = {
        downloadDelay: 1000,        // Delay between downloads (ms)
        maxRetries: 3,              // Max retries for failed downloads
        notificationTimeout: 5000,  // Notification display time
        enableNotifications: true,   // Enable browser notifications
        enableProgress: true,       // Show download progress
        enableRightClick: true,     // Enable right-click context menu
        enableKeyboardShortcut: true, // Enable keyboard shortcut (D key)
        enableAutoClose: true,      // Auto-close media viewer after download
        autoCloseDelay: 1000,       // Delay before closing media viewer
        chunkSize: 1024 * 1024,     // 1MB chunks for downloading
        progressColor: '#4caf50',
        progressErrorColor: '#D16666',
        progressCompleteColor: '#2196f3',
        enableOverlay: false        // MENONAKTIFKAN OVERLAY PADA MEDIA YANG SUDAH DI SELECT
    };
    // Global variables
    let downloadQueue = [];
    let isDownloading = false;
    let downloadCancelled = false;
    let totalFiles = 0;
    let downloadedFiles = 0;
    let hoveredElement = null;
    // Logger
    const logger = {
        info: (message, fileName = null) => {
            console.log(`[Telegram Media Downloader] ${fileName ? `${fileName}: ` : ""}${message}`);
        },
        error: (message, fileName = null) => {
            console.error(`[Telegram Media Downloader] ${fileName ? `${fileName}: ` : ""}${message}`);
        },
    };
    // Add CSS styles
    GM_addStyle(`
        .no-forwards .bubbles, .bubble, .bubble-content {
            -webkit-user-select: text!important;
            -moz-user-select: text!important;
            user-select: text!important;
        }
        .download-progress {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 9999;
            display: none;
            min-width: 250px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .download-progress h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        .download-progress-bar {
            width: 100%;
            height: 10px;
            background: #333;
            border-radius: 5px;
            margin-top: 8px;
            overflow: hidden;
        }
        .download-progress-fill {
            height: 100%;
            background: ${config.progressColor};
            width: 0%;
            transition: width 0.3s ease;
        }
        .download-progress-text {
            margin-top: 8px;
            font-size: 14px;
        }
        .cancel-download-btn {
            margin-top: 10px;
            background-color: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .cancel-download-btn:hover {
            background-color: #d32f2f;
        }
        .media-item {
            position: relative;
        }
        .media-item .download-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s;
            cursor: pointer;
            border-radius: 8px;
        }
        /* PERUBAHAN: Hanya menampilkan overlay jika diaktifkan di config */
        ${config.enableOverlay ? '.media-item:hover .download-overlay { opacity: 1; }' : ''}
        .download-overlay .download-icon {
            color: white;
            font-size: 24px;
            background: rgba(0,0,0,0.7);
            padding: 8px;
            border-radius: 50%;
        }
        .media-downloader-img-btn, .media-downloader-media-btn {
            position: absolute;
            left: 5px;
            bottom: 5px;
            z-index: 9999;
            padding: 4px 6px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        .media-downloader-img-btn:hover, .media-downloader-media-btn:hover {
            background: rgba(0,0,0,0.9);
        }
        .media-downloader-context-menu {
            position: fixed;
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
            cursor: pointer;
            z-index: 999999;
            display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .media-downloader-progress {
            position: absolute;
            left: 0;
            bottom: 0;
            height: 4px;
            width: 0%;
            background: ${config.progressColor};
            z-index: 99999;
            transition: width 0.2s linear;
            display: none;
        }
        .media-downloader-tg-btn {
            margin-left: 5px;
        }
    `);
    // Create progress element for batch downloads
    const progressElement = document.createElement('div');
    progressElement.className = 'download-progress';
    progressElement.innerHTML = `
        <h3>Downloading Media</h3>
        <div class="download-progress-bar">
            <div class="download-progress-fill"></div>
        </div>
        <div class="download-progress-text">Preparing downloads...</div>
        <button class="cancel-download-btn">Cancel</button>
    `;
    document.body.appendChild(progressElement);

    // Cancel download functionality
    progressElement.querySelector('.cancel-download-btn').addEventListener('click', () => {
        downloadCancelled = true;
        updateProgress('Download cancelled', 0);
        setTimeout(() => {
            progressElement.style.display = 'none';
        }, 2000);
    });

    // Show notification
    function showNotification(title, message) {
        if (config.enableNotifications && GM_notification) {
            GM_notification({
                title: title,
                text: message,
                timeout: config.notificationTimeout,
                onclick: () => {
                    window.focus();
                }
            });
        }
    }

    // Update progress display for batch downloads
    function updateProgress(status, percent) {
        if (!config.enableProgress) return;
        const statusElement = progressElement.querySelector('.download-progress-text');
        const progressFill = progressElement.querySelector('.download-progress-fill');
        statusElement.textContent = status;
        progressFill.style.width = `${percent}%`;
        progressElement.style.display = 'block';
        logger.info(`Download progress: ${status} (${percent}%)`);
    }

    // Create progress bar for individual media downloads
    function createProgressBar(mediaEl) {
        const bar = document.createElement('div');
        bar.className = 'media-downloader-progress';
        if (mediaEl.parentNode.style.position === 'static') {
            mediaEl.parentNode.style.position = 'relative';
        }
        mediaEl.parentNode.appendChild(bar);
        return bar;
    }

    // Update individual progress bar
    function updateProgressBar(bar, percent, done = false, error = false) {
        if (!bar) return;
        bar.style.display = 'block';
        bar.style.width = `${percent}%`;
        if (done) {
            bar.style.background = error ? config.progressErrorColor : config.progressCompleteColor;
            setTimeout(() => { bar.style.display = 'none'; }, 2000);
        }
    }

    // Create Telegram progress bar
    function createTelegramProgressBar(videoId, fileName) {
        const isDarkMode = document.documentElement.classList.contains('night') ||
                          document.documentElement.classList.contains('theme-dark');
        const container = document.getElementById('media-downloader-progress-container') || (() => {
            const div = document.createElement('div');
            div.id = 'media-downloader-progress-container';
            div.style.cssText = `
                position: fixed;
                bottom: 0;
                right: 0;
                z-index: ${location.pathname.startsWith('/k/') ? 4 : 1600};
                max-width: 20rem;
            `;
            document.body.appendChild(div);
            return div;
        })();
        const innerContainer = document.createElement('div');
        innerContainer.id = `media-downloader-progress-${videoId}`;
        innerContainer.style.cssText = `
            width: 20rem;
            margin-top: 0.4rem;
            padding: 0.6rem;
            background-color: ${isDarkMode ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.6)'};
            border-radius: 0.5rem;
        `;
        const header = document.createElement('div');
        header.style.cssText = 'display: flex; justify-content: space-between; margin-bottom: 0.5rem;';
        const title = document.createElement('p');
        title.className = 'filename';
        title.style.cssText = 'margin: 0; color: white; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
        title.textContent = fileName;
        const closeButton = document.createElement('div');
        closeButton.style.cssText = 'cursor: pointer; font-size: 1.2rem; color: #8a8a8a;';
        closeButton.innerHTML = '&times;';
        closeButton.onclick = () => container.removeChild(innerContainer);
        header.appendChild(title);
        header.appendChild(closeButton);
        const progressBar = document.createElement('div');
        progressBar.style.cssText = `
            background-color: #e2e2e2;
            position: relative;
            width: 100%;
            height: 1rem;
            border-radius: 1rem;
            overflow: hidden;
        `;
        const counter = document.createElement('p');
        counter.style.cssText = `
            position: absolute;
            z-index: 5;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            margin: 0;
            color: black;
            font-size: 0.8rem;
        `;
        const progress = document.createElement('div');
        progress.style.cssText = `
            position: absolute;
            height: 100%;
            width: 0%;
            background-color: #6093B5;
            transition: width 0.3s ease;
        `;
        progressBar.appendChild(counter);
        progressBar.appendChild(progress);
        innerContainer.appendChild(header);
        innerContainer.appendChild(progressBar);
        container.appendChild(innerContainer);
        return { counter, progress, innerContainer };
    }

    // Update Telegram progress bar
    function updateTelegramProgress(videoId, progress) {
        const container = document.getElementById(`media-downloader-progress-${videoId}`);
        if (!container) return;
        const counter = container.querySelector('p');
        const progressBar = container.querySelector('div > div:last-child');
        counter.textContent = `${progress}%`;
        progressBar.style.width = `${progress}%`;
    }

    // Complete Telegram progress bar
    function completeTelegramProgress(videoId, error = false) {
        const container = document.getElementById(`media-downloader-progress-${videoId}`);
        if (!container) return;
        const counter = container.querySelector('p');
        const progressBar = container.querySelector('div > div:last-child');
        counter.textContent = error ? 'Failed' : 'Completed';
        progressBar.style.backgroundColor = error ? config.progressErrorColor : '#B6C649';
        progressBar.style.width = '100%';
        setTimeout(() => {
            if (container.parentNode) {
                container.parentNode.removeChild(container);
            }
        }, 3000);
    }

    // Utility functions
    function hashCode(s) {
        let h = 0, l = s.length, i = 0;
        if (l > 0) while (i < l) h = ((h << 5) - h + s.charCodeAt(i++)) | 0;
        return h >>> 0;
    }

    function getFileName(url, ext) {
        try {
            const metadata = JSON.parse(decodeURIComponent(url.split('/').pop()));
            if (metadata.fileName) return metadata.fileName;
        } catch (e) {}
        return `media_${hashCode(url)}.${ext}`;
    }

    function triggerDownload(blob, fileName) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
    }

    // Check if media is visible
    function isMediaVisible(mediaEl) {
        if (!mediaEl) return false;
        // Check if element is visible in viewport
        const rect = mediaEl.getBoundingClientRect();
        const isVisible = (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth)
        );
        // For Telegram, check if media is in viewer
        const inViewer = !!mediaEl.closest('#MediaViewer, .media-viewer-whole, #stories-viewer, #StoryViewer');
        return isVisible || inViewer;
    }

    // Open media if not already opened
    async function openMediaIfNeeded(mediaEl) {
        // If media is already visible, no need to do anything
        if (isMediaVisible(mediaEl)) {
            return true;
        }
        // Special handling for Telegram
        try {
            // Find clickable element to open media
            let clickableElement = mediaEl;
            // If media is video or image in thumbnail
            if (mediaEl.tagName === 'VIDEO' || mediaEl.tagName === 'IMG') {
                // Find container element that can be clicked
                const container = mediaEl.closest('.Message, .media-container, .thumbnail, .photo');
                if (container) {
                    clickableElement = container;
                }
            }
            // Save previous state
            const wasPaused = mediaEl.tagName === 'VIDEO' || mediaEl.tagName === 'AUDIO' ? mediaEl.paused : true;
            // Click element to open media
            clickableElement.click();
            // Wait until media is opened
            await new Promise(resolve => {
                const checkVisibility = () => {
                    if (isMediaVisible(mediaEl)) {
                        resolve();
                    } else {
                        setTimeout(checkVisibility, 100);
                    }
                };
                checkVisibility();
            });
            // If media is video/audio, ensure it's fully loaded
            if (mediaEl.tagName === 'VIDEO' || mediaEl.tagName === 'AUDIO') {
                // Play briefly then pause to ensure media is loaded
                await mediaEl.play();
                mediaEl.pause();
                // Return to previous state if it should be paused
                if (wasPaused) {
                    mediaEl.pause();
                }
            }
            return true;
        } catch (e) {
            logger.error(`Failed to open media: ${e.message}`);
            return false;
        }
    }

    // Close media viewer
    function closeMediaViewer(mediaEl) {
        if (!mediaEl || !config.enableAutoClose) return;
        try {
            // Try to find close button in viewer
            const viewer = mediaEl.closest('#MediaViewer, .media-viewer-whole, #stories-viewer, #StoryViewer');
            if (viewer) {
                const closeButton = viewer.querySelector('button[title="Close"], button.close, .Button.icon-close, .btn-icon.tgico-close');
                if (closeButton) {
                    closeButton.click();
                    return;
                }
                // Alternative: press ESC key
                const escEvent = new KeyboardEvent('keydown', {
                    key: 'Escape',
                    code: 'Escape',
                    keyCode: 27,
                    which: 27,
                    bubbles: true,
                    cancelable: true
                });
                document.dispatchEvent(escEvent);
            }
        } catch (e) {
            logger.error(`Failed to close media viewer: ${e.message}`);
        }
    }

    // Resolve media source
    function resolveMediaSource(mediaEl) {
        let src = null, ext = 'mp4';
        if (mediaEl.tagName === 'VIDEO') {
            src = mediaEl.currentSrc || mediaEl.src;
            ext = 'mp4';
        } else if (mediaEl.tagName === 'AUDIO') {
            src = mediaEl.currentSrc || mediaEl.src;
            ext = 'mp3';
        } else if (mediaEl.tagName === 'IMG') {
            src = mediaEl.src;
            ext = 'jpg';
        }
        return { src, ext };
    }

    // Check if element is in chat area
    function isInChatArea(element) {
        // Check if element is in Telegram chat area
        const chatSelectors = [
            '.Message',     // WebZ
            '.message',     // WebK
            '.chat',        // General
            '.messages-container', // General
            '.chat-list',   // General
            '.history',     // WebK
            '.bubbles',     // WebK
            '.bubble',      // WebK
            '.chat-content', // WebZ
            '.chat-input-container' // WebZ
        ];
        for (const selector of chatSelectors) {
            if (element.closest(selector)) {
                return true;
            }
        }
        return false;
    }

    // Download media using chunks
    async function downloadMedia(url, fileName, progressEl, mediaEl) {
        try {
            const resp = await fetch(url, { headers: { Range: 'bytes=0-' }});
            if (!resp.ok) throw Error(`HTTP Error: ${resp.status}`);
            const contentRange = resp.headers.get('Content-Range');
            const totalSize = contentRange ? parseInt(contentRange.split('/')[1], 10) : null;
            const mime = resp.headers.get('Content-Type') || 'application/octet-stream';
            if (resp.headers.get('Accept-Ranges') === 'bytes' && totalSize) {
                const chunkSize = Math.min(config.chunkSize, totalSize);
                const segmentCount = Math.ceil(totalSize / chunkSize);
                const parts = [];
                for (let i = 0; i < segmentCount; i++) {
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize - 1, totalSize - 1);
                    const partResp = await fetch(url, {
                        headers: { Range: `bytes=${start}-${end}` }
                    });
                    if (!partResp.ok) throw Error(`Chunk Error: ${partResp.status}`);
                    const buf = await partResp.arrayBuffer();
                    parts.push(buf);
                    const percent = Math.round(((end + 1) / totalSize) * 100);
                    if (progressEl) {
                        if (progressEl.classList.contains('media-downloader-progress')) {
                            updateProgressBar(progressEl, percent, percent === 100);
                        } else {
                            updateTelegramProgress(progressEl.id.split('-').pop(), percent);
                        }
                    }
                }
                const blob = new Blob(parts, { type: mime });
                triggerDownload(blob, fileName);
                if (progressEl) {
                    if (progressEl.classList.contains('media-downloader-progress')) {
                        updateProgressBar(progressEl, 100, true);
                    } else {
                        completeTelegramProgress(progressEl.id.split('-').pop());
                    }
                }
                // Close media after download if it's a duration media
                if (mediaEl && (mediaEl.tagName === 'VIDEO' || mediaEl.tagName === 'AUDIO')) {
                    setTimeout(() => {
                        closeMediaViewer(mediaEl);
                    }, config.autoCloseDelay);
                }
            } else {
                const blob = await resp.blob();
                triggerDownload(blob, fileName);
                if (progressEl) {
                    if (progressEl.classList.contains('media-downloader-progress')) {
                        updateProgressBar(progressEl, 100, true);
                    } else {
                        completeTelegramProgress(progressEl.id.split('-').pop());
                    }
                }
                // Close media after download if it's a duration media
                if (mediaEl && (mediaEl.tagName === 'VIDEO' || mediaEl.tagName === 'AUDIO')) {
                    setTimeout(() => {
                        closeMediaViewer(mediaEl);
                    }, config.autoCloseDelay);
                }
            }
        } catch (err) {
            logger.error(`Download failed: ${err.message}`, fileName);
            if (progressEl) {
                if (progressEl.classList.contains('media-downloader-progress')) {
                    updateProgressBar(progressEl, 0, true, true);
                } else {
                    completeTelegramProgress(progressEl.id.split('-').pop(), true);
                }
            }
        }
    }

    // Download Telegram restricted media
    function downloadTelegramMedia(url, type = 'video', mediaEl) {
        const videoId = `${Math.random().toString(36).substring(2, 10)}_${Date.now()}`;
        const fileName = getFileName(url, type === 'video' ? 'mp4' : type === 'audio' ? 'ogg' : 'jpg');
        logger.info(`Telegram Download: ${url}`, fileName);
        const { counter, progress, innerContainer } = createTelegramProgressBar(videoId, fileName);
        let blobs = [];
        let nextOffset = 0;
        let totalSize = null;
        const fetchNextPart = async () => {
            try {
                const resp = await fetch(url, {
                    headers: { Range: `bytes=${nextOffset}-` }
                });
                if (![200, 206].includes(resp.status)) {
                    throw new Error(`HTTP Error: ${resp.status}`);
                }
                const mime = resp.headers.get('Content-Type').split(';')[0];
                if (!mime.startsWith(type === 'audio' ? 'audio/' : type === 'video' ? 'video/' : 'image/')) {
                    throw new Error(`Invalid MIME type: ${mime}`);
                }
                const contentRange = resp.headers.get('Content-Range');
                if (!contentRange) throw new Error('No Content-Range header');
                const match = contentRange.match(/^bytes (\d+)-(\d+)\/(\d+)$/);
                if (!match) throw new Error('Invalid Content-Range format');
                const startOffset = parseInt(match[1], 10);
                const endOffset = parseInt(match[2], 10);
                const currentTotalSize = parseInt(match[3], 10);
                if (startOffset !== nextOffset) {
                    throw new Error(`Gap detected: expected ${nextOffset}, got ${startOffset}`);
                }
                if (totalSize && currentTotalSize !== totalSize) {
                    throw new Error(`Size mismatch: expected ${totalSize}, got ${currentTotalSize}`);
                }
                nextOffset = endOffset + 1;
                totalSize = currentTotalSize;
                const blob = await resp.blob();
                blobs.push(blob);
                const percent = Math.round((nextOffset / totalSize) * 100);
                counter.textContent = `${percent}%`;
                progress.style.width = `${percent}%`;
                if (nextOffset < totalSize) {
                    fetchNextPart();
                } else {
                    const finalBlob = new Blob(blobs, { type: mime });
                    triggerDownload(finalBlob, fileName);
                    completeTelegramProgress(videoId);
                    // Close media after download if it's a duration media
                    if (mediaEl && (type === 'video' || type === 'audio')) {
                        setTimeout(() => {
                            closeMediaViewer(mediaEl);
                        }, config.autoCloseDelay);
                    }
                }
            } catch (err) {
                logger.error(`Download failed: ${err.message}`, fileName);
                completeTelegramProgress(videoId, true);
            }
        };
        fetchNextPart();
    }

    // Extract media from message and download to disk
    function downloadMediaFromMessage(msg, retryCount = 0) {
        if (!msg.media || downloadCancelled) return;
        let myMedia = null;
        let mediaType = '';
        // Check for different media types
        if (msg.media.photo) {
            myMedia = msg.media.photo;
            mediaType = 'Photo';
        } else if (msg.media.document) {
            myMedia = msg.media.document;
            mediaType = 'Document';
        } else if (msg.media.video) {
            myMedia = msg.media.video;
            mediaType = 'Video';
        } else if (msg.media.audio) {
            myMedia = msg.media.audio;
            mediaType = 'Audio';
        }
        if (!myMedia) return;
        try {
            logger.info(`Downloading ${mediaType}:`, myMedia);
            unsafeWindow.appDownloadManager.downloadToDisc({media: myMedia});
            downloadedFiles++;
            const percent = totalFiles > 0 ? Math.round((downloadedFiles / totalFiles) * 100) : 0;
            updateProgress(`Downloading: ${downloadedFiles}/${totalFiles} files`, percent);
        } catch (error) {
            logger.error('Download error:', error);
            if (retryCount < config.maxRetries) {
                logger.info(`Retrying download (${retryCount + 1}/${config.maxRetries})...`);
                setTimeout(() => downloadMediaFromMessage(msg, retryCount + 1), 1000);
            } else {
                logger.error('Max retries reached for download');
            }
        }
    }

    // Throttle download of multiple medias
    function slowDown(secs, msg) {
        if (downloadCancelled) return;
        setTimeout(() => {
            downloadMediaFromMessage(msg);
        }, secs * config.downloadDelay);
    }

    // Get message object then download
    async function downloadSingleMedia(pid, mid) {
        try {
            const msg = await unsafeWindow.mtprotoMessagePort.getMessageByPeer(pid, mid);
            if (msg && msg.media) {
                downloadMediaFromMessage(msg);
                showNotification('Download Started', 'Media download has started');
            } else {
                logger.error('No media found in message');
                showNotification('Download Error', 'No media found in this message');
            }
        } catch (error) {
            logger.error('Error getting message:', error);
            showNotification('Download Error', 'Failed to get message data');
        }
    }

    // Download multiple medias from selected messages
    async function downloadSelectedMedia() {
        try {
            const msgs = await unsafeWindow.appImManager.chat.selection.getSelectedMessages();
            if (msgs.length === 0) {
                showNotification('No Media', 'No messages selected');
                return;
            }
            startBatchDownload(msgs, 'selected messages');
        } catch (error) {
            logger.error('Error getting selected messages:', error);
            showNotification('Download Error', 'Failed to get selected messages');
        }
    }

    // Start batch download process
    function startBatchDownload(messages, source) {
        if (isDownloading) {
            showNotification('Busy', 'Another download is in progress');
            return;
        }
        isDownloading = true;
        downloadCancelled = false;
        downloadQueue = messages.filter(msg =>
            msg.media && (msg.media.photo || msg.media.document || msg.media.video || msg.media.audio)
        );
        totalFiles = downloadQueue.length;
        downloadedFiles = 0;
        if (totalFiles === 0) {
            showNotification('No Media', `No media found in ${source}`);
            isDownloading = false;
            return;
        }
        showNotification('Download Started', `Downloading ${totalFiles} files from ${source}`);
        updateProgress(`Starting download of ${totalFiles} files...`, 0);
        // Process download queue
        downloadQueue.forEach((msg, index) => {
            slowDown(index, msg);
        });
        // Reset UI after all downloads
        setTimeout(() => {
            isDownloading = false;
            if (!downloadCancelled) {
                updateProgress('Download completed!', 100);
                showNotification('Download Complete', `Successfully downloaded ${downloadedFiles} files`);
                setTimeout(() => {
                    progressElement.style.display = 'none';
                }, 3000);
            }
        }, totalFiles * config.downloadDelay + 1000);
    }

    // Add download button to media elements
    function addDownloadButton(mediaEl) {
        if (mediaEl.dataset.downloadAttached) return;
        mediaEl.dataset.downloadAttached = 'true';
        // Only add button if element is in chat area
        if (!isInChatArea(mediaEl)) {
            return;
        }
        const parent = mediaEl.parentNode;
        if (window.getComputedStyle(parent).position === 'static') {
            parent.style.position = 'relative';
        }
        // For images, create image download button
        if (mediaEl.tagName === 'IMG') {
            const imgBtn = document.createElement('button');
            imgBtn.textContent = 'ðŸ–¼ï¸';
            imgBtn.title = 'Download Gambar';
            imgBtn.className = 'media-downloader-img-btn';
            imgBtn.addEventListener('click', async () => {
                const { src, ext } = resolveMediaSource(mediaEl);
                if (!src) {
                    alert('Tidak ditemukan sumber media!');
                    return;
                }
                const fileName = `gambar_${Date.now()}.${ext}`;
                // Proceed with download
                if (src.includes('telegram')) {
                    downloadTelegramMedia(src, 'image', mediaEl);
                } else {
                    downloadMedia(src, fileName, null, mediaEl);
                }
            });
            parent.appendChild(imgBtn);
        }
        // For video/audio, create media download button
        if (mediaEl.tagName === 'VIDEO' || mediaEl.tagName === 'AUDIO') {
            const mediaBtn = document.createElement('button');
            mediaBtn.textContent = 'ðŸŽ¬';
            mediaBtn.title = 'Download Media';
            mediaBtn.className = 'media-downloader-media-btn';
            // If there's an image button, position media button next to it
            const imgBtn = parent.querySelector('.media-downloader-img-btn');
            if (imgBtn) {
                mediaBtn.style.left = '35px';
            }
            const progressBar = createProgressBar(mediaEl);
            mediaBtn.addEventListener('click', async () => {
                const { src, ext } = resolveMediaSource(mediaEl);
                if (!src) {
                    alert('Tidak ditemukan sumber media!');
                    return;
                }
                const fileName = `media_${Date.now()}.${ext}`;
                // Open media if not already opened
                await openMediaIfNeeded(mediaEl);
                // Proceed with download
                if (src.includes('telegram')) {
                    downloadTelegramMedia(src, ext === 'mp3' ? 'audio' : 'video', mediaEl);
                } else {
                    downloadMedia(src, fileName, progressBar, mediaEl);
                }
            });
            parent.appendChild(mediaBtn);
        }
    }

    // Add download overlay to media elements
    function addDownloadOverlay() {
        // PERUBAHAN: Hanya tambahkan overlay jika diaktifkan di config
        if (!config.enableOverlay) return;

        // Add download overlay to images
        document.querySelectorAll('.photo img, .video img, .document-container img').forEach(img => {
            const mediaItem = img.closest('.photo, .video, .document-container');
            if (mediaItem && !mediaItem.querySelector('.download-overlay')) {
                const overlay = document.createElement('div');
                overlay.className = 'download-overlay';
                overlay.innerHTML = '<span class="download-icon">ðŸ“¥</span>';
                overlay.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const messageEl = mediaItem.closest('[data-mid]');
                    if (messageEl) {
                        const mid = messageEl.dataset.mid;
                        const pid = messageEl.dataset.peerId;
                        downloadSingleMedia(pid, mid);
                    }
                });
                mediaItem.classList.add('media-item');
                mediaItem.appendChild(overlay);
            }
        });
    }

    // Keyboard shortcut
    if (config.enableKeyboardShortcut) {
        document.addEventListener('mouseover', (e) => {
            const el = e.target.closest('video, audio, img');
            if (el && isInChatArea(el)) {
                hoveredElement = el;
            }
        });
        document.addEventListener('mouseout', (e) => {
            if (e.target === hoveredElement) hoveredElement = null;
        });
        document.addEventListener('keydown', async (e) => {
            if (e.key.toLowerCase() === 'd' && hoveredElement) {
                e.preventDefault();
                const { src, ext } = resolveMediaSource(hoveredElement);
                if (src) {
                    const fileName = `media_${Date.now()}.${ext}`;
                    const isVideoOrAudio = hoveredElement.tagName === 'VIDEO' || hoveredElement.tagName === 'AUDIO';
                    // Only for duration media (video/audio), open media if not already opened
                    if (isVideoOrAudio) {
                        await openMediaIfNeeded(hoveredElement);
                    }
                    // Proceed with download
                    if (src.includes('telegram')) {
                        downloadTelegramMedia(src, ext === 'mp3' ? 'audio' : ext === 'jpg' ? 'image' : 'video', hoveredElement);
                    } else {
                        downloadMedia(src, fileName, null, hoveredElement);
                    }
                }
            }
        });
    }

    // Special Telegram features
    function addTelegramFeatures() {
        // For webz /a/ webapp
        setInterval(() => {
            // Stories
            const storiesContainer = document.getElementById('StoryViewer');
            if (storiesContainer) {
                const createDownloadButton = () => {
                    const downloadButton = document.createElement('button');
                    downloadButton.className = 'Button TkphaPyQ tiny translucent-white round media-downloader-tg-btn';
                    downloadButton.innerHTML = '<i class="icon icon-download"></i>';
                    downloadButton.setAttribute('type', 'button');
                    downloadButton.setAttribute('title', 'Download');
                    downloadButton.onclick = async () => {
                        // Look for video first
                        const video = storiesContainer.querySelector('video');
                        const videoSrc = video?.currentSrc || video?.src;
                        if (videoSrc) {
                            await openMediaIfNeeded(video);
                            downloadTelegramMedia(videoSrc, 'video', video);
                        } else {
                            // If no video, look for image
                            const images = storiesContainer.querySelectorAll('img.PVZ8TOWS');
                            if (images.length > 0) {
                                const imageSrc = images[images.length - 1]?.src;
                                if (imageSrc) downloadTelegramMedia(imageSrc, 'image');
                            }
                        }
                    };
                    return downloadButton;
                };
                const storyHeader = storiesContainer.querySelector('.GrsJNw3y') ||
                                   storiesContainer.querySelector('.DropdownMenu')?.parentNode;
                if (storyHeader && !storyHeader.querySelector('.media-downloader-tg-btn')) {
                    storyHeader.insertBefore(createDownloadButton(), storyHeader.querySelector('button'));
                }
            }
            // Media viewer
            const mediaContainer = document.querySelector('#MediaViewer .MediaViewerSlide--active');
            const mediaViewerActions = document.querySelector('#MediaViewer .MediaViewerActions');
            if (!mediaContainer || !mediaViewerActions) return;
            const videoPlayer = mediaContainer.querySelector('.MediaViewerContent > .VideoPlayer');
            const img = mediaContainer.querySelector('.MediaViewerContent > div > img');
            const downloadButton = document.createElement('button');
            downloadButton.className = 'Button smaller translucent-white round media-downloader-tg-btn';
            downloadButton.innerHTML = '<i class="icon icon-download"></i>';
            downloadButton.setAttribute('type', 'button');
            downloadButton.setAttribute('title', 'Download');
            if (videoPlayer) {
                const video = videoPlayer.querySelector('video');
                const videoUrl = video?.currentSrc || video?.src;
                downloadButton.setAttribute('data-tel-download-url', videoUrl);
                downloadButton.onclick = async () => {
                    await openMediaIfNeeded(video);
                    downloadTelegramMedia(videoUrl, 'video', video);
                };
                // Add to video controls
                const controls = videoPlayer.querySelector('.VideoPlayerControls');
                if (controls) {
                    const buttons = controls.querySelector('.buttons');
                    if (!buttons.querySelector('.media-downloader-tg-btn')) {
                        const spacer = buttons.querySelector('.spacer');
                        if (spacer) spacer.after(downloadButton);
                    }
                }
                // Add to topbar
                if (!mediaViewerActions.querySelector('.media-downloader-tg-btn') &&
                    !mediaViewerActions.querySelector('button[title="Download"]')) {
                    mediaViewerActions.prepend(downloadButton);
                }
            } else if (img && img.src) {
                downloadButton.setAttribute('data-tel-download-url', img.src);
                downloadButton.onclick = () => downloadTelegramMedia(img.src, 'image');
                // Add to topbar
                if (!mediaViewerActions.querySelector('.media-downloader-tg-btn') &&
                    !mediaViewerActions.querySelector('button[title="Download"]')) {
                    mediaViewerActions.prepend(downloadButton);
                }
            }
        }, 500);
        // For webk /k/ webapp
        setInterval(() => {
            // Stories
            const storiesContainer = document.getElementById('stories-viewer');
            if (storiesContainer) {
                const createDownloadButton = () => {
                    const downloadButton = document.createElement('button');
                    downloadButton.className = 'btn-icon rp media-downloader-tg-btn';
                    downloadButton.innerHTML = '<span class="tgico">â¬‡</span><div class="c-ripple"></div>';
                    downloadButton.setAttribute('type', 'button');
                    downloadButton.setAttribute('title', 'Download');
                    downloadButton.onclick = async () => {
                        // Look for video first
                        const video = storiesContainer.querySelector('video.media-video');
                        const videoSrc = video?.currentSrc || video?.src;
                        if (videoSrc) {
                            await openMediaIfNeeded(video);
                            downloadTelegramMedia(videoSrc, 'video', video);
                        } else {
                            // If no video, look for image
                            const imageSrc = storiesContainer.querySelector('img.media-photo')?.src;
                            if (imageSrc) downloadTelegramMedia(imageSrc, 'image');
                        }
                    };
                    return downloadButton;
                };
                const storyHeader = storiesContainer.querySelector('[class^="_ViewerStoryHeaderRight"]');
                const storyFooter = storiesContainer.querySelector('[class^="_ViewerStoryFooterRight"]');
                if (storyHeader && !storyHeader.querySelector('.media-downloader-tg-btn')) {
                    storyHeader.prepend(createDownloadButton());
                }
                if (storyFooter && !storyFooter.querySelector('.media-downloader-tg-btn')) {
                    storyFooter.prepend(createDownloadButton());
                }
            }
            // Media viewer
            const mediaContainer = document.querySelector('.media-viewer-whole');
            if (!mediaContainer) return;
            const mediaAspecter = mediaContainer.querySelector('.media-viewer-movers .media-viewer-aspecter');
            const mediaButtons = mediaContainer.querySelector('.media-viewer-topbar .media-viewer-buttons');
            if (!mediaAspecter || !mediaButtons) return;
            // Unhide hidden buttons
            const hiddenButtons = mediaButtons.querySelectorAll('button.btn-icon.hide');
            hiddenButtons.forEach(btn => btn.classList.remove('hide'));
            let onDownload = null;
            // Check for existing download button
            const existingDownloadBtn = mediaButtons.querySelector('button.btn-icon.tgico-download');
            if (existingDownloadBtn) {
                onDownload = () => existingDownloadBtn.click();
            }
            // Video player
            if (mediaAspecter.querySelector('.ckin__player')) {
                const controls = mediaAspecter.querySelector('.default__controls.ckin__controls');
                if (controls && !controls.querySelector('.media-downloader-tg-btn')) {
                    const brControls = controls.querySelector('.bottom-controls .right-controls');
                    const downloadButton = document.createElement('button');
                    downloadButton.className = 'btn-icon default__button tgico-download media-downloader-tg-btn';
                    downloadButton.innerHTML = '<span class="tgico">â¬‡</span>';
                    downloadButton.setAttribute('type', 'button');
                    downloadButton.setAttribute('title', 'Download');
                    if (onDownload) {
                        downloadButton.onclick = onDownload;
                    } else {
                        downloadButton.onclick = async () => {
                            const video = mediaAspecter.querySelector('video');
                            if (video) {
                                await openMediaIfNeeded(video);
                                downloadTelegramMedia(video.src, 'video', video);
                            }
                        };
                    }
                    brControls.prepend(downloadButton);
                }
            }
            // Video element
            else if (mediaAspecter.querySelector('video') && !mediaButtons.querySelector('button.btn-icon.tgico-download')) {
                const downloadButton = document.createElement('button');
                downloadButton.className = 'btn-icon tgico-download media-downloader-tg-btn';
                downloadButton.innerHTML = '<span class="tgico button-icon">â¬‡</span>';
                downloadButton.setAttribute('type', 'button');
                downloadButton.setAttribute('title', 'Download');
                if (onDownload) {
                    downloadButton.onclick = onDownload;
                } else {
                    downloadButton.onclick = async () => {
                        const video = mediaAspecter.querySelector('video');
                        if (video) {
                            await openMediaIfNeeded(video);
                            downloadTelegramMedia(video.src, 'video', video);
                        }
                    };
                }
                mediaButtons.prepend(downloadButton);
            }
            // Image
            else if (!mediaButtons.querySelector('button.btn-icon.tgico-download')) {
                const img = mediaAspecter.querySelector('img.thumbnail');
                if (img && img.src) {
                    const downloadButton = document.createElement('button');
                    downloadButton.className = 'btn-icon tgico-download media-downloader-tg-btn';
                    downloadButton.innerHTML = '<span class="tgico button-icon">â¬‡</span>';
                    downloadButton.setAttribute('type', 'button');
                    downloadButton.setAttribute('title', 'Download');
                    if (onDownload) {
                        downloadButton.onclick = onDownload;
                    } else {
                        downloadButton.onclick = () => downloadTelegramMedia(img.src, 'image');
                    }
                    mediaButtons.prepend(downloadButton);
                }
            }
        }, 500);
    }

    // Initialize the script
    function init() {
        const colCenter = document.querySelector('#column-center');
        if (!colCenter) {
            logger.error('Column center not found');
            return;
        }
        // Array of class names for media
        const clArray = ['photo', 'audio', 'video', 'voice-message', 'media-round', 'grouped-item', 'document-container', 'sticker'];
        // HTML code for buttons
        const downloadBtnHtml = '<div class="btn-menu-item rp-overflow" id="down-btn"><span class="mytgico btn-menu-item-icon" style="font-size: 16px;">ðŸ“¥</span><span class="i18n btn-menu-item-text">Download</span></div>';
        const batchBtnHtml = '&nbsp;&nbsp;<button class="btn-primary btn-transparent text-bold" id="batch-btn" title="Download Selected Media"><span class="mytgico" style="padding-bottom: 2px;">ðŸ“¥</span>&nbsp;<span class="i18n">D/L Selected</span></button>';
        // Variables for the current message and peer ID
        let curMid, curPid, needBtn = false;
        // Unlock Ctrl+C to copy selected text
        const origListener = EventTarget.prototype.addEventListener;
        EventTarget.prototype.addEventListener = function(type) {
            if (type !== 'copy') {
                origListener.apply(this, arguments);
            }
        };
        // Handle right-click events
        colCenter.addEventListener('mouseup', (e) => {
            if (e.button === 2) { // Right mouse button
                needBtn = false;
                // Test if the current chat has restricted content saving
                if (document.querySelector('.no-forwards')) {
                    const closest = e.target.closest('[data-mid]');
                    if (closest) {
                        // Check if the element contains media classes
                        if (clArray.some(clName => closest.classList.contains(clName))) {
                            curMid = closest.dataset.mid;
                            curPid = closest.dataset.peerId;
                            needBtn = true;
                        }
                    }
                }
            }
        });
        // Observe DOM changes
        const observer = new MutationObserver((mutList) => {
            mutList.forEach((mut) => {
                mut.addedNodes.forEach((anod) => {
                    // Check if context menu has been added
                    if (anod.id === 'bubble-contextmenu' && needBtn) {
                        // Add the custom Download button
                        anod.querySelector('.btn-menu-item')?.insertAdjacentHTML('beforebegin', downloadBtnHtml);
                        anod.querySelector('#down-btn')?.addEventListener('click', () => {
                            downloadSingleMedia(curPid, curMid);
                        });
                    }
                    // Check if selection popup has been added
                    if (anod.classList?.contains('selection-wrapper')) {
                        const container = anod.querySelector('.selection-container-left');
                        if (container && !document.getElementById('batch-btn')) {
                            container.insertAdjacentHTML('beforeend', batchBtnHtml);
                            anod.querySelector('#batch-btn')?.addEventListener('click', downloadSelectedMedia);
                        }
                    }
                });
                // Add download overlays to new media elements
                addDownloadOverlay();
                // Add download buttons to new media elements
                document.querySelectorAll('video, audio, img').forEach(el => {
                    if (!el.closest('.media-downloader-ignore')) {
                        addDownloadButton(el);
                    }
                });
            });
        });
        // Start observing
        observer.observe(colCenter, { subtree: true, childList: true });
        // Initial scan for existing media elements
        addDownloadOverlay();
        // Add download buttons to existing media elements
        document.querySelectorAll('video, audio, img').forEach(el => {
            if (!el.closest('.media-downloader-ignore')) {
                addDownloadButton(el);
            }
        });
        // Initialize special Telegram features
        addTelegramFeatures();
        logger.info('Telegram Media Downloader initialized');
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();
